{"version":3,"file":"index.mjs","sources":["../src/helpers/attributes.ts","../src/helpers/array.ts","../src/backcompat/index.ts","../src/backcompat/adr.ts","../src/backcompat/geo.ts","../src/backcompat/hentry.ts","../src/backcompat/hfeed.ts","../src/backcompat/hnews.ts","../src/backcompat/hproduct.ts","../src/backcompat/hreview.ts","../src/backcompat/vcard.ts","../src/backcompat/hresume.ts","../src/backcompat/vevent.ts","../src/backcompat/item.ts","../src/backcompat/hreview-aggregate.ts","../src/helpers/nodeMatchers.ts","../src/helpers/findChildren.ts","../src/helpers/experimental.ts","../src/helpers/textContent.ts","../src/implied/name.ts","../src/implied/url.ts","../src/helpers/images.ts","../src/implied/photo.ts","../src/helpers/valueClassPattern.ts","../src/helpers/url.ts","../src/microformats/property.ts","../src/microformats/properties.ts","../src/helpers/includes.ts","../src/microformats/parse.ts","../src/validator.ts","../src/rels/rels.ts","../src/helpers/documentSetup.ts","../src/helpers/metaformats.ts","../src/index.ts","../src/parser.ts"],"sourcesContent":["import { Attribute, Element } from \"../types\";\n\nexport const getAttribute = (\n  node: Element,\n  name: string,\n): Attribute | undefined => node.attrs.find((attr) => attr.name === name);\n\nexport const getAttributeValue = (\n  node: Element,\n  name: string,\n): string | undefined => {\n  const attr = getAttribute(node, name)?.value;\n  return attr?.length ? attr : undefined;\n};\n\nexport const getClassNames = (\n  node: Element,\n  matcher?: RegExp | string,\n): string[] => {\n  const classNames = getAttributeValue(node, \"class\")?.split(\" \") || [];\n\n  return matcher\n    ? classNames.filter((name) =>\n        typeof matcher === \"string\"\n          ? name.startsWith(matcher)\n          : name.match(matcher),\n      )\n    : classNames;\n};\n\nexport const getClassNameIntersect = <T extends string>(\n  node: Element,\n  toCompare: T[],\n): T[] =>\n  getClassNames(node).filter((name: string): name is T =>\n    toCompare.includes(name as T),\n  );\n\nexport const hasClassName = (node: Element, className: string): boolean =>\n  getClassNames(node).some((name) => name === className);\n\nexport const hasClassNameIntersect = (\n  node: Element,\n  toCompare: string[],\n): boolean => getClassNames(node).some((name) => toCompare.includes(name));\n\nexport const getAttributeIfTag = (\n  node: Element,\n  tagNames: string[],\n  attr: string,\n): string | undefined =>\n  tagNames.includes(node.tagName) ? getAttributeValue(node, attr) : undefined;\n\nexport const hasRelIntersect = (node: Element, toCompare: string[]): boolean =>\n  Boolean(\n    getAttributeValue(node, \"rel\")\n      ?.split(\" \")\n      .some((name) => toCompare.includes(name)),\n  );\n\nexport const getRelIntersect = (node: Element, toCompare: string[]): string[] =>\n  getAttributeValue(node, \"rel\")\n    ?.split(\" \")\n    .filter((name) => toCompare.includes(name)) || [];\n","export const flatten = <T>(prev: T[], curr: T[]): T[] => [...prev, ...curr];\n","import { Element } from \"../types\";\nimport { adr } from \"./adr\";\nimport { geo } from \"./geo\";\nimport { hentry } from \"./hentry\";\nimport { hfeed } from \"./hfeed\";\nimport { hnews } from \"./hnews\";\nimport { hproduct } from \"./hproduct\";\nimport { hreview } from \"./hreview\";\nimport { vcard } from \"./vcard\";\nimport {\n  getClassNameIntersect,\n  hasClassNameIntersect,\n  getRelIntersect,\n  hasRelIntersect,\n  getAttributeValue,\n  getClassNames,\n} from \"../helpers/attributes\";\nimport { hreviewAggregate } from \"./hreview-aggregate\";\nimport { hresume } from \"./hresume\";\nimport { vevent } from \"./vevent\";\nimport { item } from \"./item\";\nimport { flatten } from \"../helpers/array\";\n\nexport const backcompat = {\n  adr,\n  geo,\n  hentry,\n  hfeed,\n  hnews,\n  hproduct,\n  hreview,\n  vcard,\n  hresume,\n  vevent,\n  item,\n  \"hreview-aggregate\": hreviewAggregate,\n};\n\nexport type BackcompatRoot = keyof typeof backcompat;\n\nexport const backcompatRoots = Object.keys(backcompat) as BackcompatRoot[];\n\nexport const getBackcompatRootClassNames = (node: Element): BackcompatRoot[] =>\n  getClassNameIntersect(node, backcompatRoots);\n\nexport const convertV1RootClassNames = (node: Element): string[] => {\n  const classNames = getBackcompatRootClassNames(node)\n    .map((cl) => backcompat[cl].type)\n    .reduce(flatten);\n\n  return classNames.length > 1\n    ? classNames.filter((cl) => cl !== \"h-item\")\n    : classNames;\n};\n\nexport const hasBackcompatMicroformatProperty = (\n  node: Element,\n  roots: BackcompatRoot[],\n): boolean =>\n  roots.some((root) => {\n    const { properties, rels } = backcompat[root];\n    return (\n      hasClassNameIntersect(node, Object.keys(properties)) ||\n      (rels && hasRelIntersect(node, Object.keys(rels)))\n    );\n  });\n\nexport const convertV1PropertyClassNames = (\n  node: Element,\n  roots: BackcompatRoot[],\n): string[] => [\n  ...new Set(\n    roots\n      .map((root) => {\n        const { properties, rels } = backcompat[root];\n\n        const classes = getClassNameIntersect(\n          node,\n          Object.keys(properties),\n        ).map((cl) => properties[cl]);\n\n        const relClasses =\n          (rels &&\n            getRelIntersect(node, Object.keys(rels)).map((cl) => rels[cl])) ||\n          [];\n\n        return [...classes, ...relClasses];\n      })\n      .reduce(flatten),\n  ),\n];\n\nexport const getV1IncludeNames = (node: Element): string[] => {\n  const itemref = getAttributeValue(node, \"itemref\");\n\n  if (itemref) {\n    return itemref.split(\" \");\n  }\n\n  if (getClassNames(node).includes(\"include\")) {\n    const hrefAttr = node.tagName === \"object\" ? \"data\" : \"href\";\n\n    const href = getAttributeValue(node, hrefAttr);\n\n    if (href && href.startsWith(\"#\")) {\n      return [href.substring(1)];\n    }\n  }\n\n  const headers = node.tagName === \"td\" && getAttributeValue(node, \"headers\");\n\n  if (headers) {\n    return [headers];\n  }\n\n  return [];\n};\n","import { Backcompat } from \"../types\";\n\nexport const adr: Backcompat = {\n  type: [\"h-adr\"],\n  properties: {\n    \"country-name\": \"p-country-name\",\n    locality: \"p-locality\",\n    region: \"p-region\",\n    \"street-address\": \"p-street-address\",\n    \"postal-code\": \"p-postal-code\",\n    \"extended-address\": \"p-extended-address\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const geo: Backcompat = {\n  type: [\"h-geo\"],\n  properties: {\n    latitude: \"p-latitude\",\n    longitude: \"p-longitude\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hentry: Backcompat = {\n  type: [\"h-entry\"],\n  properties: {\n    author: \"p-author\",\n    \"entry-content\": \"e-content\",\n    \"entry-summary\": \"p-summary\",\n    \"entry-title\": \"p-name\",\n    updated: \"dt-updated\",\n  },\n  rels: {\n    bookmark: \"u-url\",\n    tag: \"p-category\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hfeed: Backcompat = {\n  type: [\"h-feed\"],\n  properties: {\n    author: \"p-author\",\n    photo: \"u-photo\",\n    url: \"u-url\",\n  },\n  rels: {\n    tag: \"p-category\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hnews: Backcompat = {\n  type: [\"h-news\"],\n  properties: {\n    entry: \"p-entry\",\n    \"source-org\": \"p-source-org\",\n    dateline: \"p-dateline\",\n    geo: \"p-geo\",\n  },\n  rels: {\n    principles: \"u-principles\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hproduct: Backcompat = {\n  type: [\"h-product\"],\n  properties: {\n    price: \"p-price\",\n    description: \"p-description\",\n    fn: \"p-name\",\n    review: \"p-review\",\n    brand: \"p-brand\",\n    url: \"u-url\",\n    photo: \"u-photo\",\n  },\n  rels: {\n    tag: \"p-category\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hreview: Backcompat = {\n  type: [\"h-review\"],\n  properties: {\n    item: \"p-item\",\n    rating: \"p-rating\",\n    reviewer: \"p-author\",\n    summary: \"p-name\",\n    url: \"u-url\",\n    description: \"e-content\",\n  },\n  rels: {\n    bookmark: \"u-url\",\n    tag: \"p-category\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const vcard: Backcompat = {\n  type: [\"h-card\"],\n  properties: {\n    fn: \"p-name\",\n    url: \"u-url\",\n    org: \"p-org\",\n    adr: \"p-adr\",\n    tel: \"p-tel\",\n    title: \"p-job-title\",\n    email: \"u-email\",\n    photo: \"u-photo\",\n    agent: \"p-agent\",\n    \"family-name\": \"p-family-name\",\n    \"given-name\": \"p-given-name\",\n    \"additional-name\": \"p-additional-name\",\n    \"honorific-prefix\": \"p-honorific-prefix\",\n    \"honorific-suffix\": \"p-honorific-suffix\",\n    key: \"p-key\",\n    label: \"p-label\",\n    logo: \"u-logo\",\n    mailer: \"p-mailer\",\n    nickname: \"p-nickname\",\n    note: \"p-note\",\n    sound: \"u-sound\",\n    geo: \"p-geo\",\n    bday: \"dt-bday\",\n    class: \"p-class\",\n    rev: \"p-rev\",\n    role: \"p-role\",\n    \"sort-string\": \"p-sort-string\",\n    tz: \"p-tz\",\n    uid: \"u-uid\",\n  },\n  rels: {\n    tag: \"p-category\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hresume: Backcompat = {\n  type: [\"h-resume\"],\n  properties: {\n    contact: \"p-contact\",\n    experience: \"p-experience\",\n    summary: \"p-summary\",\n    skill: \"p-skill\",\n    education: \"p-education\",\n    affiliation: \"p-affiliation\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const vevent: Backcompat = {\n  type: [\"h-event\"],\n  properties: {\n    summary: \"p-name\",\n    dtstart: \"dt-start\",\n    dtend: \"dt-end\",\n    duration: \"dt-duration\",\n    description: \"p-description\",\n    attendee: \"p-attendee\",\n    location: \"p-location\",\n    url: \"u-url\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const item: Backcompat = {\n  type: [\"h-item\"],\n  properties: {\n    fn: \"p-name\",\n    photo: \"u-photo\",\n    url: \"u-url\",\n  },\n};\n","import { Backcompat } from \"../types\";\n\nexport const hreviewAggregate: Backcompat = {\n  type: [\"h-review-aggregate\"],\n  properties: {\n    rating: \"p-rating\",\n    average: \"p-average\",\n    best: \"p-best\",\n    count: \"p-count\",\n    item: \"p-item\",\n    url: \"u-url\",\n    fn: \"p-name\",\n  },\n};\n","import { TextNode, Node, Element } from \"../types\";\nimport {\n  getAttribute,\n  hasClassNameIntersect,\n  getClassNames,\n} from \"./attributes\";\nimport {\n  backcompatRoots,\n  hasBackcompatMicroformatProperty,\n  BackcompatRoot,\n} from \"../backcompat\";\n\nconst classRegex = (prefix: string): RegExp =>\n  new RegExp(`^${prefix}-([a-z0-9]+-)?([a-z]+-)*[a-z]+$`);\n\nconst rootClassRegex = classRegex(\"h\");\nconst propClassRegex = classRegex(\"(p|e|u|dt)\");\n\nexport const isElement = (node: Node): node is Element =>\n  \"tagName\" in node && \"childNodes\" in node;\n\nexport const isTag =\n  (tagName: string) =>\n  (node: Node): node is Element =>\n    isElement(node) && node.tagName === tagName;\n\nexport const isTextNode = (node: Node): node is TextNode => \"value\" in node;\n\nexport const isMicroformatV2Root = (node: Element): boolean =>\n  getClassNames(node).some((cl) => cl.match(rootClassRegex));\n\nconst isMicroformatV1Root = (node: Element): boolean =>\n  hasClassNameIntersect(node, backcompatRoots);\n\nexport const isMicroformatRoot = (node: Element): boolean =>\n  isMicroformatV2Root(node) || isMicroformatV1Root(node);\n\nexport const isMicroformatV1Property = (\n  node: Element,\n  roots: BackcompatRoot[],\n): boolean => hasBackcompatMicroformatProperty(node, roots);\n\nexport const isMicroformatV2Property = (node: Element): boolean =>\n  getClassNames(node, propClassRegex).length > 0;\n\nexport const isMicroformatChild = (\n  node: Element,\n  roots: BackcompatRoot[],\n): boolean =>\n  !isMicroformatV2Property(node) &&\n  !isMicroformatV1Property(node, roots) &&\n  isMicroformatRoot(node);\n\nexport const isBase = (node: Element): boolean =>\n  Boolean(\n    isElement(node) && node.tagName === \"base\" && getAttribute(node, \"href\"),\n  );\n\nexport const isValueClass = (node: Element): boolean =>\n  isElement(node) && hasClassNameIntersect(node, [\"value\", \"value-title\"]);\n\nexport const isRel = (node: Element): boolean =>\n  Boolean(\n    isElement(node) &&\n      node.attrs.some((attr) => attr.name === \"rel\") &&\n      node.attrs.some((attr) => attr.name === \"href\"),\n  );\n","import { Document, Element } from \"../types\";\nimport { isMicroformatRoot, isElement } from \"./nodeMatchers\";\nimport { BackcompatRoot, getBackcompatRootClassNames } from \"../backcompat\";\n\ntype Matcher =\n  | ((node: Element) => boolean)\n  | ((node: Element, roots: BackcompatRoot[]) => boolean);\n\ninterface ReducerOptions {\n  matcher: Matcher;\n  roots: BackcompatRoot[];\n}\n\nconst getElementChildren = (node: Element | Document): Element[] =>\n  node.childNodes.filter(Boolean).filter(isElement);\n\nconst reducer = (\n  microformats: Element[],\n  node: Element,\n  options: ReducerOptions,\n): Element[] => {\n  const { matcher, roots } = options;\n  const match = matcher(node, roots) && node;\n\n  // if we have a match and it's a h- element, stop looking\n  if (match && isMicroformatRoot(node)) {\n    return [...microformats, node];\n  }\n\n  if (isMicroformatRoot(node)) {\n    return microformats;\n  }\n\n  const childMicroformats = getElementChildren(node).reduce<Element[]>(\n    (prev, curr) => reducer(prev, curr, options),\n    match ? [match] : [],\n  );\n\n  return [...microformats, ...childMicroformats];\n};\n\nexport const findChildren = (\n  parent: Element | Document,\n  matcher: Matcher,\n): Element[] => {\n  const findOptions = {\n    roots: isElement(parent) ? getBackcompatRootClassNames(parent) : [],\n    stopAtRoot: true,\n    matcher,\n  };\n\n  return getElementChildren(parent).reduce<Element[]>(\n    (prev, curr) => reducer(prev, curr, findOptions),\n    [],\n  );\n};\n","import { ExperimentalName, ParserOptions } from \"../types\";\n\nexport const isEnabled = (\n  options: ParserOptions,\n  flag: ExperimentalName,\n): boolean => {\n  if (!options || !options.experimental) {\n    return false;\n  }\n\n  return options.experimental[flag] || false;\n};\n","import { getAttributeValue } from \"./attributes\";\nimport { isElement, isTextNode } from \"./nodeMatchers\";\nimport { ParserOptions, Node, Element } from \"../types\";\nimport { isEnabled } from \"./experimental\";\n\nconst imageValue = (node: Element): string | undefined =>\n  getAttributeValue(node, \"alt\")?.trim() ??\n  getAttributeValue(node, \"src\")?.trim();\n\nconst walk = (current: string, node: Node): string => {\n  if (isElement(node)) {\n    if ([\"style\", \"script\"].includes(node.tagName)) {\n      return current;\n    }\n\n    if (node.tagName === \"img\") {\n      const value = imageValue(node);\n\n      if (value) {\n        return `${current} ${value} `;\n      }\n    }\n\n    return node.childNodes.reduce<string>(walk, current);\n  } else if (isTextNode(node)) {\n    return `${current}${node.value}`;\n  }\n\n  return current;\n};\n\nconst impliedWalk = (current: string, node: Node): string => {\n  if (isElement(node)) {\n    if ([\"style\", \"script\"].includes(node.tagName)) {\n      return current;\n    }\n\n    if (node.tagName === \"img\") {\n      const value = getAttributeValue(node, \"alt\") || \"\";\n      return `${current}${value}`;\n    }\n\n    return node.childNodes.reduce<string>(impliedWalk, current);\n  } else if (isTextNode(node)) {\n    return `${current}${node.value}`;\n  }\n\n  return current;\n};\n\nconst experimentalWalk = (current: string, node: Node): string => {\n  if (isElement(node)) {\n    if ([\"style\", \"script\"].includes(node.tagName)) {\n      return current;\n    }\n\n    if (node.tagName === \"img\") {\n      const value = imageValue(node);\n\n      if (value) {\n        return `${current} ${value} `;\n      }\n    }\n\n    if (node.tagName === \"br\") {\n      return `${current}\\n`;\n    }\n\n    if (node.tagName === \"p\") {\n      return node.childNodes.reduce<string>(experimentalWalk, `${current}\\n`);\n    }\n\n    return node.childNodes.reduce<string>(experimentalWalk, current);\n  } else if (isTextNode(node)) {\n    const value = node.value.replace(/[\\t\\n\\r]/g, \" \");\n    if (value) {\n      return `${current}${value}`;\n    }\n  }\n\n  return current;\n};\n\nconst experimentalTextContent = (node: Element): string =>\n  node.childNodes\n    .reduce<string>(experimentalWalk, \"\")\n    .replace(/ +/g, \" \")\n    .replace(/ ?\\n ?/g, \"\\n\")\n    .trim();\n\nexport const textContent = (node: Element, options: ParserOptions): string => {\n  if (isEnabled(options, \"textContent\")) {\n    return experimentalTextContent(node);\n  }\n\n  return node.childNodes.reduce<string>(walk, \"\").trim();\n};\n\nexport const impliedTextContent = (\n  node: Element,\n  options: ParserOptions,\n): string => {\n  if (isEnabled(options, \"textContent\")) {\n    return experimentalTextContent(node);\n  }\n\n  return node.childNodes.reduce<string>(impliedWalk, \"\").trim();\n};\n\nexport const relTextContent = (\n  node: Element,\n  options: ParserOptions,\n): string => {\n  if (isEnabled(options, \"textContent\")) {\n    return experimentalTextContent(node);\n  }\n\n  return node.childNodes.reduce<string>(impliedWalk, \"\");\n};\n","import { impliedTextContent } from \"../helpers/textContent\";\nimport { isElement } from \"../helpers/nodeMatchers\";\nimport { getClassNames, getAttributeIfTag } from \"../helpers/attributes\";\nimport { ParsingOptions, Element } from \"../types\";\n\nconst parseNode = (node: Element): string | undefined =>\n  getAttributeIfTag(node, [\"img\", \"area\"], \"alt\") ??\n  getAttributeIfTag(node, [\"abbr\"], \"title\");\n\nconst parseChild = (node: Element): string | undefined => {\n  const children = node.childNodes.filter(isElement);\n  return children.length ? parseNode(children[0]) : undefined;\n};\n\nconst parseGrandchild = (node: Element): string | undefined => {\n  const children = node.childNodes.filter(isElement);\n  return children.length === 1 ? parseChild(children[0]) : undefined;\n};\n\nexport const impliedName = (\n  node: Element,\n  children: Element[],\n  options: ParsingOptions,\n): string | undefined => {\n  if (children.some((child) => getClassNames(child, /^(p|e|h)-/).length)) {\n    return;\n  }\n\n  return (\n    parseNode(node) ??\n    parseChild(node) ??\n    parseGrandchild(node) ??\n    impliedTextContent(node, options)\n  );\n};\n","import { Element } from \"../types\";\n\nimport { getClassNames, getAttributeIfTag } from \"../helpers/attributes\";\nimport { isElement, isMicroformatV2Root } from \"../helpers/nodeMatchers\";\n\nconst parseNode = (node: Element): string | undefined =>\n  getAttributeIfTag(node, [\"a\", \"area\"], \"href\");\n\nconst parseChild = (node: Element): string | undefined => {\n  const children = node.childNodes.filter(isElement);\n  const a = children.filter((child) => child.tagName === \"a\");\n  const area = children.filter((child) => child.tagName === \"area\");\n\n  for (const list of [a, area]) {\n    if (list.length === 1 && !isMicroformatV2Root(list[0])) {\n      return parseNode(list[0]);\n    }\n  }\n\n  return;\n};\n\nconst parseGrandchild = (node: Element): string | undefined => {\n  const children = node.childNodes.filter(isElement);\n  return children.length === 1 ? parseChild(children[0]) : undefined;\n};\n\nexport const impliedUrl = (\n  node: Element,\n  children: Element[],\n): string | undefined => {\n  if (children.some((child) => getClassNames(child, \"u-\").length)) {\n    return;\n  }\n\n  return parseNode(node) ?? parseChild(node) ?? parseGrandchild(node);\n};\n","import { Element } from \"../types\";\n\nimport { getAttributeValue } from \"./attributes\";\nimport { Image, ParsingOptions } from \"../types\";\n\nexport const parseImage = (\n  node: Element,\n  { inherited }: Partial<ParsingOptions> = {},\n): Image | string | undefined => {\n  if (node.tagName !== \"img\") {\n    return;\n  }\n\n  const alt =\n    (!inherited || !inherited.roots || !inherited.roots.length) &&\n    getAttributeValue(node, \"alt\");\n  const value = getAttributeValue(node, \"src\");\n  return alt ? { alt, value } : value;\n};\n","import { Image, Element } from \"../types\";\nimport { parseImage } from \"../helpers/images\";\nimport { getAttributeValue, getClassNames } from \"../helpers/attributes\";\nimport { isElement, isMicroformatV2Root } from \"../helpers/nodeMatchers\";\n\nconst parseNode = (node: Element): Image | string | undefined => {\n  if (node.tagName === \"img\") {\n    return parseImage(node);\n  }\n\n  if (node.tagName === \"object\") {\n    return getAttributeValue(node, \"data\");\n  }\n\n  return;\n};\n\nconst parseChild = (node: Element): Image | string | undefined => {\n  const children = node.childNodes.filter(isElement);\n  const imgs = children.filter((child) => child.tagName === \"img\");\n  const objects = children.filter((child) => child.tagName === \"object\");\n\n  for (const list of [imgs, objects]) {\n    if (list.length === 1 && !isMicroformatV2Root(list[0])) {\n      return parseNode(list[0]);\n    }\n  }\n\n  return;\n};\n\nconst parseGrandchild = (node: Element): string | Image | undefined => {\n  const children = node.childNodes.filter(isElement);\n  return children.length === 1 ? parseChild(children[0]) : undefined;\n};\n\nexport const impliedPhoto = (\n  node: Element,\n  children: Element[],\n): Image | string | undefined => {\n  if (children.some((child) => getClassNames(child, \"u-\").length)) {\n    return;\n  }\n\n  return parseNode(node) ?? parseChild(node) ?? parseGrandchild(node);\n};\n","import { getAttributeValue, hasClassName } from \"./attributes\";\nimport { textContent } from \"./textContent\";\nimport { findChildren } from \"./findChildren\";\nimport { isValueClass } from \"./nodeMatchers\";\nimport { ParsingOptions, Element } from \"../types\";\n\ninterface Options {\n  datetime: boolean;\n}\n\nconst datetimeProp = (node: Element): string | undefined =>\n  getAttributeValue(node, \"datetime\");\n\nconst valueTitle = (node: Element): string | undefined => {\n  if (hasClassName(node, \"value-title\")) {\n    return getAttributeValue(node, \"title\");\n  }\n\n  return;\n};\n\nconst handleDate = (dateStrings: string[]): string | undefined =>\n  dateStrings\n    .sort((a) =>\n      // Sort the date elements to move date components to the start\n      a.match(/^[0-9]{4}/) ? -1 : 1,\n    )\n    .join(\" \")\n    .trim()\n    .replace(\n      // remove \":\" from timezones\n      /((\\+|-)[0-2][0-9]):([0-5][0-9])$/,\n      (s) => s.replace(\":\", \"\"),\n    )\n    .replace(\n      // handle am and pm times\n      /([0-2]?[0-9])(:[0-5][0-9])?(:[0-5][0-9])?(a\\.?m\\.?|p\\.?m\\.?)/i,\n      (_s, hour, min, sec, ampm) => {\n        const isAm = /a/i.test(ampm);\n\n        // if the time is:\n        // - am, zero pad\n        // - pm, add 12 hours\n        const newHour = isAm\n          ? hour.padStart(2, \"0\")\n          : `${parseInt(hour, 10) + 12}`;\n\n        // reconstruct, and add mins if any are missing\n        return `${newHour}${min ? min : \":00\"}${sec || \"\"}`;\n      },\n    )\n    .toUpperCase();\n\nexport const valueClassPattern = (\n  node: Element,\n  options: ParsingOptions & Partial<Options>,\n): string | undefined => {\n  const values = findChildren(node, isValueClass);\n\n  if (!values.length) {\n    return;\n  }\n\n  if (options.datetime) {\n    const date = values.map(\n      (node) =>\n        datetimeProp(node) ?? valueTitle(node) ?? textContent(node, options),\n    );\n    return handleDate(date);\n  }\n\n  return values\n    .map((node) => valueTitle(node) ?? textContent(node, options))\n    .join(\"\")\n    .trim();\n};\n","export const isLocalLink = (link: string): boolean =>\n  !link.includes(\"://\") && !link.startsWith(\"#\");\n\nexport const applyBaseUrl = (link: string, baseUrl: string): string =>\n  new URL(link, baseUrl).toString();\n","import { serialize } from \"parse5\";\n\nimport {\n  getAttributeIfTag,\n  getClassNames,\n  getAttributeValue,\n} from \"../helpers/attributes\";\nimport {\n  ParsedProperty,\n  MicroformatProperty,\n  Html,\n  PropertyType,\n  ParsingOptions,\n  Element,\n} from \"../types\";\nimport { isMicroformatRoot } from \"../helpers/nodeMatchers\";\nimport { parseMicroformat } from \"./parse\";\nimport { valueClassPattern } from \"../helpers/valueClassPattern\";\nimport { textContent, impliedTextContent } from \"../helpers/textContent\";\nimport { parseImage } from \"../helpers/images\";\nimport { isLocalLink, applyBaseUrl } from \"../helpers/url\";\nimport { convertV1PropertyClassNames } from \"../backcompat\";\nimport { isEnabled } from \"../helpers/experimental\";\n\nconst propertyRegexp = /^(p|u|e|dt)-/;\n\nconst getType = (className: string): PropertyType =>\n  (className.startsWith(\"p-\") && \"p\") ||\n  (className.startsWith(\"u-\") && \"u\") ||\n  (className.startsWith(\"e-\") && \"e\") ||\n  \"dt\";\n\nexport const parseP = (node: Element, options: ParsingOptions): string =>\n  valueClassPattern(node, options) ??\n  getAttributeIfTag(node, [\"abbr\", \"link\"], \"title\") ??\n  getAttributeIfTag(node, [\"data\"], \"value\") ??\n  getAttributeIfTag(node, [\"img\", \"area\"], \"alt\") ??\n  getAttributeIfTag(node, [\"meta\"], \"content\") ??\n  impliedTextContent(node, options);\n\nexport const parseU = (\n  node: Element,\n  options: ParsingOptions,\n): MicroformatProperty => {\n  const url =\n    getAttributeIfTag(node, [\"a\", \"area\", \"link\"], \"href\") ??\n    parseImage(node, options) ??\n    getAttributeIfTag(node, [\"audio\", \"source\", \"iframe\", \"video\"], \"src\") ??\n    getAttributeIfTag(node, [\"video\"], \"poster\") ??\n    getAttributeIfTag(node, [\"object\"], \"data\") ??\n    valueClassPattern(node, options) ??\n    getAttributeIfTag(node, [\"abbr\"], \"title\") ??\n    getAttributeIfTag(node, [\"data\", \"input\"], \"value\") ??\n    getAttributeIfTag(node, [\"meta\"], \"content\") ??\n    textContent(node, options);\n\n  if (typeof url === \"string\" && isLocalLink(url)) {\n    return applyBaseUrl(url, options.baseUrl);\n  }\n\n  return typeof url === \"string\" ? url.trim() : url;\n};\n\nexport const parseDt = (node: Element, options: ParsingOptions): string =>\n  valueClassPattern(node, { ...options, datetime: true }) ??\n  getAttributeIfTag(node, [\"time\", \"ins\", \"del\"], \"datetime\") ??\n  getAttributeIfTag(node, [\"abbr\"], \"title\") ??\n  getAttributeIfTag(node, [\"data\", \"input\"], \"value\") ??\n  getAttributeIfTag(node, [\"meta\"], \"content\") ??\n  textContent(node, options);\n\nexport const parseE = (node: Element, options: ParsingOptions): Html => {\n  const value = {\n    value: textContent(node, options),\n    html: serialize(node).trim(),\n  };\n\n  const lang =\n    isEnabled(options, \"lang\") &&\n    (getAttributeValue(node, \"lang\") || options.inherited.lang);\n\n  return lang ? { ...value, lang } : value;\n};\n\nconst getPropertyClassNames = (\n  node: Element,\n  { inherited }: ParsingOptions,\n): string[] => {\n  if (inherited.roots.length) {\n    return convertV1PropertyClassNames(node, inherited.roots);\n  }\n\n  return getClassNames(node, /^(p|u|e|dt)-/);\n};\n\nconst handleProperty = (\n  node: Element,\n  type: PropertyType,\n  options: ParsingOptions,\n): MicroformatProperty => {\n  if (type === \"p\") {\n    return parseP(node, options);\n  }\n\n  if (type === \"e\") {\n    return parseE(node, options);\n  }\n\n  if (type === \"u\") {\n    return parseU(node, options);\n  }\n\n  return parseDt(node, options);\n};\n\nexport const parseProperty = (\n  child: Element,\n  options: ParsingOptions,\n): ParsedProperty[] =>\n  getPropertyClassNames(child, options)\n    .map((className): ParsedProperty | undefined => {\n      const type = getType(className);\n      const key = className.replace(propertyRegexp, \"\");\n      const value =\n        [\"u\", \"p\", \"e\", \"dt\"].includes(type) && isMicroformatRoot(child)\n          ? parseMicroformat(child, {\n              ...options,\n              valueType: type,\n              valueKey: key,\n            })\n          : handleProperty(child, type, options);\n\n      return { type, key, value };\n    })\n    .filter((p): p is ParsedProperty => Boolean(p));\n\n/**\n * Some properties require knowledge of other properties to be parsed correctly\n * Apply known post-initial-parse rules here:\n *  - dt-end should be dt-start aware\n */\nexport const postParseNode = (\n  prop: ParsedProperty,\n  _i: number,\n  all: ParsedProperty[],\n): ParsedProperty => {\n  // Imply an end date if only time specified\n  if (\n    prop.type === \"dt\" &&\n    prop.key === \"end\" &&\n    typeof prop.value === \"string\" &&\n    !prop.value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}/) &&\n    prop.value.match(/^[0-9]{2}:[0-9]{2}/)\n  ) {\n    const value = all.find(\n      (p) =>\n        p.type === \"dt\" && p.key === \"start\" && typeof prop.value === \"string\",\n    )?.value as string;\n\n    if (value) {\n      const date = value.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}/);\n\n      return { ...prop, value: `${date} ${prop.value}` };\n    }\n  }\n\n  return prop;\n};\n","import {\n  ParsedProperty,\n  MicroformatProperties,\n  ParsingOptions,\n  Element,\n} from \"../types\";\nimport { findChildren } from \"../helpers/findChildren\";\nimport { impliedName } from \"../implied/name\";\nimport { impliedUrl } from \"../implied/url\";\nimport {\n  isMicroformatV1Property,\n  isMicroformatV2Property,\n} from \"../helpers/nodeMatchers\";\nimport { impliedPhoto } from \"../implied/photo\";\nimport { parseProperty, postParseNode } from \"./property\";\nimport { flatten } from \"../helpers/array\";\n\nconst addProperty = (\n  properties: MicroformatProperties,\n  { key, value }: Pick<ParsedProperty, \"key\" | \"value\">,\n): void => {\n  if (typeof value === \"undefined\") {\n    return;\n  }\n\n  if (!properties[key] && !Array.isArray(properties[key])) {\n    properties[key] = [value];\n    return;\n  }\n\n  properties[key].push(value);\n};\n\nconst getPropertyNodes = (node: Element, options: ParsingOptions): Element[] =>\n  !options.inherited.roots.length\n    ? findChildren(node, isMicroformatV2Property)\n    : findChildren(node, isMicroformatV1Property);\n\nexport const microformatProperties = (\n  node: Element,\n  options: ParsingOptions,\n): MicroformatProperties => {\n  const properties: MicroformatProperties = {};\n\n  const propertyNodes = getPropertyNodes(node, options);\n\n  propertyNodes\n    .map((child) => parseProperty(child, options))\n    .reduce(flatten, [])\n    .map(postParseNode)\n    .forEach((prop) => addProperty(properties, prop));\n\n  if (options.implyProperties && !options.inherited.roots.length) {\n    if (typeof properties.name === \"undefined\") {\n      addProperty(properties, {\n        key: \"name\",\n        value: impliedName(node, propertyNodes, options),\n      });\n    }\n\n    if (typeof properties.url === \"undefined\") {\n      addProperty(properties, {\n        key: \"url\",\n        value: impliedUrl(node, propertyNodes),\n      });\n    }\n\n    if (typeof properties.photo === \"undefined\") {\n      addProperty(properties, {\n        key: \"photo\",\n        value: impliedPhoto(node, propertyNodes),\n      });\n    }\n  }\n\n  return properties;\n};\n","import { Element } from \"../types\";\n\nimport {\n  isMicroformatV2Root,\n  isElement,\n  isMicroformatRoot,\n} from \"./nodeMatchers\";\nimport { ParsingOptions } from \"../types\";\nimport { getV1IncludeNames } from \"../backcompat\";\n\nconst applyIncludes = (node: Element, options: ParsingOptions): void => {\n  const includeNames = getV1IncludeNames(node);\n\n  includeNames.forEach((name) => {\n    const include = options.idRefs[name];\n    if (include) {\n      node.childNodes.push(include);\n    }\n  });\n\n  node.childNodes.forEach(\n    (child) =>\n      isElement(child) &&\n      !isMicroformatRoot(child) &&\n      applyIncludes(child, options),\n  );\n};\n\nexport const applyIncludesToRoot = (\n  node: Element,\n  options: ParsingOptions,\n): void => {\n  if (isMicroformatV2Root(node)) {\n    return;\n  }\n\n  applyIncludes(node, options);\n};\n","import {\n  MicroformatRoot,\n  PropertyType,\n  ParsingOptions,\n  Element,\n} from \"../types\";\nimport { microformatProperties } from \"./properties\";\nimport { textContent } from \"../helpers/textContent\";\nimport { getAttributeValue, getClassNames } from \"../helpers/attributes\";\nimport { findChildren } from \"../helpers/findChildren\";\nimport {\n  isMicroformatChild,\n  isMicroformatRoot,\n  isMicroformatV2Root,\n} from \"../helpers/nodeMatchers\";\nimport {\n  convertV1RootClassNames,\n  getBackcompatRootClassNames,\n  BackcompatRoot,\n} from \"../backcompat\";\nimport { applyIncludesToRoot } from \"../helpers/includes\";\nimport { parseE, parseDt } from \"./property\";\nimport { isEnabled } from \"../helpers/experimental\";\n\ninterface ParseMicroformatOptions extends ParsingOptions {\n  valueType?: PropertyType;\n  valueKey?: string;\n}\n\nconst getMicroformatType = (node: Element): string[] => {\n  const v2 = getClassNames(node, \"h-\");\n  return v2.length ? v2 : convertV1RootClassNames(node);\n};\n\nconst getRoots = (node: Element): BackcompatRoot[] =>\n  isMicroformatV2Root(node) ? [] : getBackcompatRootClassNames(node);\n\nconst getId = (node: Element): string | undefined =>\n  isMicroformatV2Root(node) ? getAttributeValue(node, \"id\") : undefined;\n\nexport const parseMicroformat = (\n  node: Element,\n  options: ParseMicroformatOptions,\n): MicroformatRoot => {\n  applyIncludesToRoot(node, options);\n\n  const roots = getRoots(node);\n  const id = getId(node);\n  const lang = getAttributeValue(node, \"lang\") || options.inherited.lang;\n  const children = findChildren(node, isMicroformatChild);\n  const inherited = { lang, roots };\n\n  const item: MicroformatRoot = {\n    type: getMicroformatType(node).sort(),\n    properties: microformatProperties(node, {\n      ...options,\n      implyProperties: !findChildren(node, isMicroformatRoot).length,\n      inherited,\n    }),\n  };\n\n  if (id) {\n    item.id = id;\n  }\n\n  if (isEnabled(options, \"lang\") && lang) {\n    item.lang = lang;\n  }\n\n  if (children.length) {\n    item.children = children.map((child) =>\n      parseMicroformat(child, { ...options, inherited }),\n    );\n  }\n\n  if (options.valueType === \"p\") {\n    item.value =\n      (item.properties.name && item.properties.name[0]) ??\n      getAttributeValue(node, \"title\") ??\n      textContent(node, options);\n  }\n\n  if (options.valueType === \"u\") {\n    item.value =\n      (item.properties.url && item.properties.url[0]) ??\n      textContent(node, options);\n  }\n\n  /**\n   * The `value` is set as per default parsing as nothing else has been added\n   * to the spec. A proposal has been made:\n   * https://github.com/microformats/microformats2-parsing/issues/71\n   */\n  if (options.valueType === \"dt\") {\n    item.value = parseDt(node, options);\n  }\n\n  /**\n   * There is some ambigutity on how this should be handled.\n   * At the moment, we're following other parsers and keeping `value` a string\n   * and adding `html` as an undocumented property.\n   */\n  if (options.valueType === \"e\") {\n    return { ...parseE(node, options), ...item };\n  }\n\n  if (options.valueKey && !item.value) {\n    /**\n     * There's a lot of complexity and ambiguity on how this case should be handled.\n     * We should fall back to the `value` property of the nested MicroformatRoot or Image\n     */\n    const value =\n      item.properties[options.valueKey] && item.properties[options.valueKey][0];\n\n    if (value) {\n      item.value = typeof value === \"string\" ? value : value.value;\n    }\n  }\n\n  return item;\n};\n","import { isElement, isTag } from \"./helpers/nodeMatchers\";\nimport { Document } from \"./types\";\n\nconst assertIsString = (str: unknown, name: string): string => {\n  if (typeof str === \"undefined\") {\n    throw new TypeError(`Microformats parser: ${name} not provided`);\n  }\n\n  if (typeof str !== \"string\") {\n    throw new TypeError(`Microformats parser: ${name} is not a string`);\n  }\n\n  if (str === \"\") {\n    throw new TypeError(`Microformats parser: ${name} cannot be empty`);\n  }\n\n  return str;\n};\n\nconst assertIsBoolean = (bool: unknown, name: string): boolean => {\n  if (typeof bool !== \"boolean\") {\n    throw new TypeError(`Microformats parser: ${name} is not a boolean`);\n  }\n\n  return bool;\n};\n\nconst assertIsObject = (\n  obj: unknown,\n  allowedKeys: string[],\n  name: string,\n): Record<string, unknown> => {\n  if (typeof obj === \"undefined\") {\n    throw new TypeError(`Microformats parser: ${name} is not provided`);\n  }\n\n  if (typeof obj !== \"object\") {\n    throw new TypeError(`Microformats parser: ${name} is not an object`);\n  }\n\n  if (Array.isArray(obj)) {\n    throw new TypeError(`Microformats parser: ${name} is not an object`);\n  }\n\n  if (obj === null) {\n    throw new TypeError(`Microformats parser: ${name} cannot be null`);\n  }\n\n  const unknownKeys = Object.keys(obj).filter(\n    (key) => !allowedKeys.includes(key),\n  );\n\n  if (unknownKeys.length) {\n    throw new TypeError(\n      `Microformats parser: ${name} contains unknown properties: ${unknownKeys.join(\n        \", \",\n      )}`,\n    );\n  }\n\n  return obj as Record<string, unknown>;\n};\n\nexport const validator = (\n  unknownHtml: unknown,\n  unknownOptions: unknown,\n): void => {\n  assertIsString(unknownHtml, \"HTML\");\n\n  const options = assertIsObject(\n    unknownOptions,\n    [\"baseUrl\", \"experimental\"],\n    \"options\",\n  );\n\n  const baseUrl = assertIsString(options.baseUrl, \"baseUrl\");\n\n  // verify the url provided is valid\n  new URL(baseUrl);\n\n  if (\"experimental\" in options) {\n    const experimental = assertIsObject(\n      options.experimental,\n      [\"lang\", \"textContent\", \"metaformats\"],\n      \"experimental\",\n    );\n\n    if (\"lang\" in experimental) {\n      assertIsBoolean(experimental.lang, \"experimental.lang\");\n    }\n\n    if (\"textContent\" in experimental) {\n      assertIsBoolean(experimental.textContent, \"experimental.textContent\");\n    }\n\n    if (\"metaformats\" in experimental) {\n      assertIsBoolean(experimental.metaformats, \"experimental.metaformats\");\n    }\n  }\n};\n\nexport const validateParsedHtml = (doc: Document): void => {\n  // <html> and <body> are always defined (based on tests)\n  // Provide error handling in the event they are ever not defined\n  const html = doc.childNodes.find(isTag(\"html\"));\n\n  if (!html) {\n    throw new Error(\"Microformats parser: No <html> element found\");\n  }\n\n  const body = html.childNodes.find(isTag(\"body\"));\n\n  if (!body) {\n    throw new Error(\"Microformats parser: No <body> element found\");\n  }\n\n  // if we have no body children, it's the result of invalid HTML\n  if (!body.childNodes.filter(isElement).length) {\n    throw new Error(\"Microformats parser: unable to parse HTML\");\n  }\n};\n","import { Rels, RelUrls, ParserOptions, Element } from \"../types\";\nimport { getAttributeValue } from \"../helpers/attributes\";\nimport { relTextContent } from \"../helpers/textContent\";\n\ninterface ParseRelOptions {\n  rels: Rels;\n  relUrls: RelUrls;\n}\n\nexport const parseRel = (\n  child: Element,\n  { rels, relUrls }: ParseRelOptions,\n  options: ParserOptions,\n): void => {\n  /**\n   * Ignores used as this method is only ever called if they are defined\n   * But required for TS typechecking\n   */\n  const text = relTextContent(child, options);\n  const rel = getAttributeValue(child, \"rel\");\n  const href = getAttributeValue(child, \"href\")?.trim();\n  const title = getAttributeValue(child, \"title\");\n  const media = getAttributeValue(child, \"media\");\n  const hreflang = getAttributeValue(child, \"hreflang\");\n  const type = getAttributeValue(child, \"type\");\n\n  if (!rel || !href) {\n    return;\n  }\n\n  rel.split(\" \").forEach((rel) => {\n    if (!rels[rel]) {\n      rels[rel] = [];\n    }\n\n    if (!rels[rel].includes(href)) {\n      rels[rel].push(href);\n    }\n\n    if (!relUrls[href]) {\n      relUrls[href] = { rels: [rel], text };\n    } else if (!relUrls[href].rels.includes(rel)) {\n      relUrls[href].rels.push(rel);\n      relUrls[href].rels.sort();\n    }\n\n    if (text && !relUrls[href].text) {\n      relUrls[href].text = text;\n    }\n\n    if (title && !relUrls[href].title) {\n      relUrls[href].title = title;\n    }\n\n    if (media && !relUrls[href].media) {\n      relUrls[href].media = media;\n    }\n\n    if (hreflang && !relUrls[href].hreflang) {\n      relUrls[href].hreflang = hreflang;\n    }\n\n    if (type && !relUrls[href].type) {\n      relUrls[href].type = type;\n    }\n  });\n};\n","import { ParserOptions, IdRefs, Rels, RelUrls } from \"../types\";\nimport { getAttribute, getAttributeValue } from \"./attributes\";\nimport { isLocalLink, applyBaseUrl } from \"./url\";\nimport { isElement, isRel, isBase } from \"./nodeMatchers\";\nimport { parseRel } from \"../rels/rels\";\nimport { Document, Element } from \"../types\";\n\ninterface DocumentSetupResult {\n  idRefs: IdRefs;\n  rels: Rels;\n  relUrls: RelUrls;\n  baseUrl: string;\n  lang?: string;\n}\n\nexport const findBase = (node: Element | Document): string | undefined => {\n  for (const child of node.childNodes) {\n    if (!isElement(child)) {\n      continue;\n    }\n\n    if (isBase(child)) {\n      return getAttributeValue(child, \"href\");\n    }\n\n    const base = findBase(child);\n\n    if (base) {\n      return base;\n    }\n  }\n\n  return;\n};\n\n// this is mutating the object, and will mutate it for everything else :-/\n\nconst handleNode = (\n  node: Element | Document,\n  result: DocumentSetupResult,\n  options: ParserOptions,\n): void => {\n  for (const i in node.childNodes) {\n    const child = node.childNodes[i];\n\n    if (!isElement(child)) {\n      continue;\n    }\n\n    /**\n     * Delete <template> tags from the document\n     */\n    if (child.tagName === \"template\") {\n      delete node.childNodes[i];\n    }\n\n    /**\n     * Extract 'lang' from the <html> or a <meta> tag\n     * Always take the first value found\n     */\n    if (!result.lang) {\n      if (child.tagName === \"html\") {\n        result.lang = getAttributeValue(child, \"lang\");\n      }\n\n      if (\n        child.tagName === \"meta\" &&\n        getAttributeValue(child, \"http-equiv\") === \"Content-Language\"\n      ) {\n        result.lang = getAttributeValue(child, \"content\");\n      }\n    }\n\n    /**\n     * Apply the baseUrl to all [href], [src] and object[data] attributes\n     */\n    const attrsToApplyBaseUrl =\n      child.tagName === \"object\" ? [\"data\"] : [\"href\", \"src\"];\n\n    attrsToApplyBaseUrl.forEach((attrName) => {\n      const attr = getAttribute(child, attrName);\n\n      if (attr && isLocalLink(attr.value)) {\n        attr.value = applyBaseUrl(attr.value, result.baseUrl);\n      } else if (attr) {\n        attr.value = attr.value.trim();\n      }\n    });\n\n    /**\n     * If we have an ID, add this node to the ID reference map\n     */\n    const id = getAttributeValue(child, \"id\");\n\n    if (id && !result.idRefs[id]) {\n      result.idRefs[id] = child;\n    }\n\n    if (isRel(child)) {\n      parseRel(child, result, options);\n    }\n\n    /**\n     * Repeat this process for this node's children\n     */\n    handleNode(child, result, options);\n  }\n};\n\nexport const documentSetup = (\n  node: Document,\n  options: ParserOptions,\n): DocumentSetupResult => {\n  const result = {\n    idRefs: {},\n    rels: {},\n    relUrls: {},\n    baseUrl: findBase(node) ?? options.baseUrl,\n    lang: undefined,\n  };\n\n  handleNode(node, result, options);\n\n  return result;\n};\n","import { Document, Element } from \"../types\";\nimport { MicroformatRoot, ParsingOptions } from \"../types\";\nimport {\n  getAttributeIfTag,\n  getAttributeValue,\n  hasRelIntersect,\n} from \"./attributes\";\nimport { isEnabled } from \"./experimental\";\nimport { isElement, isTag } from \"./nodeMatchers\";\n\n/** Special key for title tag in meta collection */\nconst TITLE_TAG_KEY = \"<title>\";\nconst CANONICAL_URL_KEY = \"<canonical>\";\nconst MEDIA_TYPES = [\"image\", \"video\", \"audio\"];\n\ninterface ComplexMediaMeta {\n  value: string;\n  alt: string;\n}\ntype MetaTagContent = string | ComplexMediaMeta;\n\n/**\n * Creates a normalized store for meta tags\n */\nconst initializeMetaContentCollection = (): MetaContentCollection => {\n  /**\n   * Collection of all relevant meta tag content\n   * Since tag order isn't guaranteed, need to collect all value before applying defaults\n   */\n  const metaContent: Record<string, MetaTagContent[]> = {};\n\n  /**\n   * Gets the values of the first property found\n   * @param properties Array of properties to look for, preferred item first\n   */\n  const get = (properties: string[]) => {\n    for (const key of properties) {\n      if (metaContent[key]) {\n        return metaContent[key];\n      }\n    }\n    return;\n  };\n\n  /**\n   * Stores meta tag values.\n   *\n   * Includes following normalization rules:\n   * - Duplicates are removed from repeated (array) tags\n   * - src, url, and secure_url media tags are treated same as base (e.g. og:image:url -> og:image)\n   * - Alt text is added as property on last image url\n   */\n  const set = (key: string, value: string) => {\n    // Split tag name to normalize values like \"og:video:url\"\n    const [domain, type, subtype] = key.split(\":\");\n\n    // Media tags specific parsing\n    if (\n      (domain === \"og\" || domain === \"twitter\") &&\n      MEDIA_TYPES.includes(type)\n    ) {\n      if (subtype === \"alt\") {\n        const existingMedia = metaContent[`${domain}:${type}`];\n\n        if (existingMedia?.length) {\n          const last = existingMedia.pop();\n\n          if (typeof last === \"string\") {\n            existingMedia.push({ value: last, alt: value });\n          } else if (last) {\n            // Found duplicate alt text tag so re-inserting existing\n            // last should always be object. if condition added for types\n            existingMedia.push(last);\n          }\n        }\n\n        return; // Stop as alt text is already added\n      } else if ([\"url\", \"secure_url\"].includes(subtype)) {\n        // Mutate key to normalize different url values\n        // Duplicates will be cleaned up on insertion\n        key = `${domain}:${type}`;\n      }\n    }\n    const existing = metaContent[key];\n\n    if (existing) {\n      const isDuplicate = existing\n        .map((existingValue) =>\n          typeof existingValue === \"string\"\n            ? existingValue\n            : existingValue.value,\n        )\n        .some((existingValue) => value === existingValue);\n\n      if (!isDuplicate) {\n        metaContent[key].push(value);\n      } // Else ignore duplicates\n    } else {\n      metaContent[key] = [value];\n    }\n  };\n\n  return {\n    metaContent,\n    set,\n    get,\n  };\n};\n\ninterface MetaContentCollection {\n  metaContent: Record<string, MetaTagContent[]>;\n  set: (key: string, value: string) => void;\n  get: (properties: string[]) => MetaTagContent[] | undefined;\n}\n\nconst collectMetaTags = (head: Element): MetaContentCollection => {\n  const metaTags = initializeMetaContentCollection();\n\n  for (const i in head.childNodes) {\n    const child = head.childNodes[i];\n\n    if (!isElement(child)) {\n      continue;\n    }\n\n    const content = getAttributeIfTag(child, [\"meta\"], \"content\");\n    if (content) {\n      // Tags keys usually use the \"name\" attribute but open graph uses \"property\"\n      // Consider them separately in case a meta tag uses both\n      // e.g. <meta property=\"og:title\" name=\"author\" content=\"Johnny Complex\" >\n      const property = getAttributeValue(child, \"property\");\n      if (property) {\n        metaTags.set(property, content);\n      }\n\n      const name = getAttributeValue(child, \"name\");\n      if (name && name !== property) {\n        metaTags.set(name, content);\n      }\n    } else if (child.tagName === \"title\" && \"value\" in child.childNodes[0]) {\n      metaTags.set(TITLE_TAG_KEY, child.childNodes[0].value);\n    } else if (\n      child.tagName === \"link\" &&\n      hasRelIntersect(child, [\"canonical\"])\n    ) {\n      const canonicalUrl = getAttributeValue(child, \"href\");\n      if (canonicalUrl) {\n        metaTags.set(CANONICAL_URL_KEY, canonicalUrl);\n      }\n    }\n  }\n  return metaTags;\n};\n\n/**\n * Collect meta content into a microformat object\n * @param metaTags Previously parsed meta tag collection\n * @param options Library parsing options\n */\nconst combineRoot = (\n  metaTags: MetaContentCollection,\n  options: ParsingOptions,\n): MicroformatRoot[] => {\n  const item: MicroformatRoot = { properties: {} };\n\n  if (isEnabled(options, \"lang\") && options.inherited.lang) {\n    item.lang = options.inherited.lang;\n  }\n\n  /**\n   * Define property on microformat root if values are found\n   * @param property Key of microformats property\n   * @param value Array of values for the property. Empty and undefined values are not added.\n   */\n  const setMicroformatProp = (\n    property: string,\n    value: MetaTagContent[] = [],\n  ) => {\n    const filteredValue = value.filter(Boolean);\n    if (filteredValue.length) {\n      item.properties[property] = filteredValue;\n    }\n  };\n\n  let impliedRootClass = \"h-entry\";\n  const [ogType] = metaTags.get([\"og:type\"]) ?? [];\n  if (ogType && typeof ogType === \"string\") {\n    if (ogType === \"profile\") {\n      impliedRootClass = \"h-card\";\n    } else if ([\"music\", \"video\"].some((type) => ogType.includes(type))) {\n      impliedRootClass = \"h-cite\";\n    } // else h-entry\n  }\n  item.type = [impliedRootClass];\n\n  setMicroformatProp(\n    \"name\",\n    metaTags.get([\"og:title\", \"twitter:title\", TITLE_TAG_KEY]),\n  );\n  setMicroformatProp(\n    \"summary\",\n    metaTags.get([\"og:description\", \"twitter:description\", \"description\"]),\n  );\n  setMicroformatProp(\"featured\", metaTags.get([\"og:image\", \"twitter:image\"]));\n  setMicroformatProp(\"video\", metaTags.get([\"og:video\", \"twitter:video\"]));\n  setMicroformatProp(\"audio\", metaTags.get([\"og:audio\", \"twitter:audio\"]));\n  setMicroformatProp(\n    \"published\",\n    metaTags.get([\"article:published_time\", \"date\"]),\n  );\n  setMicroformatProp(\"updated\", metaTags.get([\"article:modified_time\"]));\n  setMicroformatProp(\"author\", metaTags.get([\"article:author\", \"author\"]));\n  setMicroformatProp(\"url\", metaTags.get([\"og:url\", CANONICAL_URL_KEY]));\n\n  // Publication properties useful for h-cite\n  setMicroformatProp(\n    \"publication\",\n    metaTags.get([\"og:site_name\", \"publisher\"]),\n  );\n\n  if (impliedRootClass === \"h-card\") {\n    setMicroformatProp(\"given-name\", metaTags.get([\"profile:first_name\"]));\n    setMicroformatProp(\"family-name\", metaTags.get([\"profile:last_name\"]));\n  }\n\n  if (Object.keys(item.properties).length === 0) {\n    return [];\n  }\n\n  return [item];\n};\n\nexport const parseMetaformats = (\n  doc: Document,\n  options: ParsingOptions,\n): MicroformatRoot[] => {\n  // Per validation, html element will always be found\n  const html = doc.childNodes.find(isTag(\"html\"));\n  const head = html?.childNodes.find(isTag(\"head\"));\n\n  // Per manual testing, head will always be defined\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const metaContent = collectMetaTags(head!);\n  return combineRoot(metaContent, options);\n};\n","import { parser } from \"./parser\";\nimport { validator } from \"./validator\";\nimport { ParsedDocument } from \"./types\";\n\nexport interface Options {\n  baseUrl: string;\n  experimental?: {\n    lang?: boolean;\n    textContent?: boolean;\n    metaformats?: boolean;\n  };\n}\n\nexport const mf2 = (html: string, options: Options): ParsedDocument => {\n  validator(html, options);\n  return parser(html, options);\n};\n","import { parse } from \"parse5\";\n\nimport { findChildren } from \"./helpers/findChildren\";\nimport { parseMicroformat } from \"./microformats/parse\";\nimport { isMicroformatRoot } from \"./helpers/nodeMatchers\";\nimport { ParsedDocument, ParserOptions, ParsingOptions } from \"./types\";\nimport { validateParsedHtml } from \"./validator\";\nimport { documentSetup } from \"./helpers/documentSetup\";\nimport { parseMetaformats } from \"./helpers/metaformats\";\nimport { isEnabled } from \"./helpers/experimental\";\n\nexport const parser = (\n  html: string,\n  options: ParserOptions,\n): ParsedDocument => {\n  const doc = parse(html);\n  validateParsedHtml(doc);\n\n  const { idRefs, rels, relUrls, baseUrl, lang } = documentSetup(doc, options);\n\n  const parsingOptions: ParsingOptions = {\n    ...options,\n    baseUrl,\n    idRefs,\n    inherited: { roots: [], lang },\n  };\n  let items = findChildren(doc, isMicroformatRoot).map((mf) =>\n    parseMicroformat(mf, parsingOptions),\n  );\n\n  if (items.length === 0 && isEnabled(parsingOptions, \"metaformats\")) {\n    items = parseMetaformats(doc, parsingOptions);\n  }\n\n  return {\n    rels,\n    \"rel-urls\": relUrls,\n    items,\n  };\n};\n"],"names":["getAttribute","node","name","attrs","find","attr","getAttributeValue","_a","value","length","undefined","getClassNames","matcher","classNames","split","filter","startsWith","match","getClassNameIntersect","toCompare","includes","hasClassNameIntersect","some","getAttributeIfTag","tagNames","tagName","hasRelIntersect","Boolean","flatten","prev","curr","backcompat","adr","type","properties","locality","region","geo","latitude","longitude","hentry","author","updated","rels","bookmark","tag","hfeed","photo","url","hnews","entry","dateline","principles","hproduct","price","description","fn","review","brand","hreview","item","rating","reviewer","summary","vcard","org","tel","title","email","agent","key","label","logo","mailer","nickname","note","sound","bday","class","rev","role","tz","uid","hresume","contact","experience","skill","education","affiliation","vevent","dtstart","dtend","duration","attendee","location","average","best","count","backcompatRoots","Object","keys","getBackcompatRootClassNames","classRegex","prefix","RegExp","rootClassRegex","propClassRegex","isElement","isTag","isTextNode","isMicroformatV2Root","cl","isMicroformatRoot","isMicroformatV1Root","isMicroformatV1Property","roots","root","hasBackcompatMicroformatProperty","isMicroformatV2Property","isMicroformatChild","isBase","isValueClass","isRel","getElementChildren","childNodes","reducer","microformats","options","childMicroformats","reduce","findChildren","parent","findOptions","isEnabled","flag","experimental","imageValue","_b","trim","_c","walk","current","impliedWalk","experimentalWalk","replace","experimentalTextContent","textContent","impliedTextContent","parseNode","parseChild","children","impliedName","child","parseGrandchild","a","area","list","impliedUrl","parseImage","inherited","alt","imgs","objects","impliedPhoto","valueTitle","className","hasClassName","valueClassPattern","values","datetime","date","map","datetimeProp","sort","join","s","_s","hour","min","sec","ampm","test","padStart","parseInt","toUpperCase","isLocalLink","link","applyBaseUrl","baseUrl","URL","toString","propertyRegexp","parseDt","_e","_d","parseE","html","serialize","lang","handleProperty","parseP","_j","_h","_g","_f","parseU","parseProperty","Set","classes","relClasses","getRelIntersect","convertV1PropertyClassNames","getPropertyClassNames","getType","parseMicroformat","valueType","valueKey","p","postParseNode","prop","_i","all","addProperty","Array","isArray","push","microformatProperties","propertyNodes","getPropertyNodes","forEach","implyProperties","applyIncludes","includeNames","itemref","hrefAttr","href","substring","headers","getV1IncludeNames","include","idRefs","getMicroformatType","v2","convertV1RootClassNames","applyIncludesToRoot","getRoots","id","getId","assertIsString","str","TypeError","assertIsBoolean","bool","assertIsObject","obj","allowedKeys","unknownKeys","parseRel","relUrls","text","relTextContent","rel","media","hreflang","findBase","base","handleNode","result","i","attrName","TITLE_TAG_KEY","CANONICAL_URL_KEY","MEDIA_TYPES","parseMetaformats","doc","metaTags","setMicroformatProp","property","filteredValue","impliedRootClass","ogType","get","combineRoot","head","metaContent","set","domain","subtype","existingMedia","last","pop","existing","existingValue","initializeMetaContentCollection","content","canonicalUrl","collectMetaTags","mf2","unknownHtml","unknownOptions","metaformats","validator","parse","Error","body","validateParsedHtml","documentSetup","parsingOptions","items","mf","parser"],"mappings":"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"}